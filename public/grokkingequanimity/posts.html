<div id='posts'><div id='post'><div id='posttitle'>Feeling Legitimate</div><div id='	postdate'>Sun May 31 2015 22:19:44 GMT-0700 (PDT)</div><br><div id='posttext'>The whole site is now configured for SSL through some awesome free, SSL certs from StartCom (StartSSL). I had an excellent time learning how to use openssl, all about certificate chaining, and the security features of modern TLS. I can now blog safely, and add forms of content creation for users to feel good about.<br><br>I am feeling like this is a legitimate web site. I will continue to update my portfolio page, make blog posts, and think about some cool apps that people would like. I everything will progressively upgrade. I am also considering some webserver alternatives like ulib. Check out <a href="https://www.techempower.com/benchmarks/">TechEmpower</a> for some <i>really</i> impressive webserver benchmarks. My plan is to build out the site more, and eventually create a functionally similar backend using ulib or another performance-oriented solution. Then, I can run my own benchmarks for legitimate purposes. Who knows, maybe I'll find that NodeJS websockets are quick and I wont need to actually shift architectures. That would be cool.<br><br><b>Lets Talk Gamification</b><br><br>I think gamification is awesome. It is a clear way to excite users and make them want to come back for more. Maybe I have simply enjoyed too many video games in my life. Nonetheless, I hope to come up with some apps/products where users can actually "build" a certain identity and maintain a small to large desire to come back to the site. Currently, there isn't really any reason at all for anyone to come to the site. I'll say that maybe my apps have interesting source code, you might want to check out the climbing log, or read some blog posts; but this thing is NOT gamified yet. Let's get addicted.</div></div><hr><div id='post'><div id='posttitle'>I Should Wear Shades, Simple Code</div><div id='	postdate'>Thu May 28 2015 17:22:02 GMT-0700 (PDT)</div><br><div id='posttext'>I should wear shades not only becase the future of tech is so bright, but because blue-eyed peoples are sensitive to the sun's rays.<br><br>Anyways... I would like to reiterate the previous post and state that the developers of the future will not need to work so hard when it comes to deploying massively scalable and truly reliable applications. But be weary, for every new, unstanardized technology comes a lot of <b>junk</b> and it is critical we remember the importance of <b><i>simple, clear-cut architecture solutions</i></b>. For instance, NodeJS has made web application development very quick for me, and I like it for this reason alone. However there were far too many snippets and examples online where developers crowded their JS files with unnecessary requires or recreated the wheel. NPM is filled with trash; practically to the brim, such that you need to check the last commit on GitHub, read through source, and compare packages. In general the industry is filled with hype, and I intend to stick to the grits of what's true in our connected world. That includes: BSD sockets, pure JavaScript, HTML, and CSS for the web, a reliable key-value store like ectd for distributed systems, and simple coding practices. Why use DOCTYPE again? Why use Coffeescript again? Why even containerize something which has automatic restarts built-in and a carefully organized set of tasks (such that resources are controlled)? Why use nothing but JSON in REST API's? Why use several layers of functions, methods, and variables using confusing terminology just to wrap a POSIX socket?<br><br>Just remember, the more lines of code you think you need (from bits in the cache and up), the slower your thingy is gonna get.</div></div><hr><div id='post'><div id='posttitle'>DevOps for Software Developers, not Computer Engineers</div><div id='	postdate'>Tue May 26 2015 18:15:19 GMT-0700 (PDT)</div><br><div id='posttext'>I am enjoying a ride on a great wave into the age of cloud computing, where old hardware + software legacy infrastructure is looking utterly decrepit, and where solutions like Docker, Kubernetes, Apache Mesos, Rocket, and Azure are the young and spicy choices for the next generation of DevOps.<br><br>Take a breather.<br><br>The point of this post is that software developers in the next generation will not be confused and will not need to meddle with a layer of messy "hardware infrastructure." I think Apache Mesos sums it up nicely:<blockquote cite="http://mesos.apache.org/">Program against your datacenter like itâ€™s a single pool of resources.</blockquote>This implies that developers within a startup of the next generation can deal with a single endpoint (server address, hosted on the strength of a cluster of machines), which can reliably handle incoming requests from all the company's users.<br><br>As an engineer I see this as a chance to add additional low-level programming language features which handle these additional resources. A system which organizes a cluster of machines will be built into a languages' framework such that, code handling an incoming request, will automatically send it to the proper machine (load balancing) on the cluster which has the proper available resource (process, disk space, CPU, etc...).<br><br>The architecture which hosts this blog as an "app", is prepared for this new wave. For each app a new NodeJS process is spawned. This is forward-looking in the sense that, load balancing is intuitive (spawn the process somewhere else). However, I do not think that the current set of options are completely realized. Docker has an odd set of terminology which fits their architecture nicely but not really my mind. Apache Mesos appears promising with a nice master/slave machine configuration scheme, but I'm not sold. I'm looking for some high-quality NodeJS packages which handle cluster management at a low level so that I can find out where my MongoDB server is at run-time and give my other apps the right address.<br><br>I'm skeptical as to how much I actually know about the topic, so that is all for now. The point is yet still, that these first-generation cluster computing solutions are not seamless. I see NodeJS as a way to seamlessly serve requests of all kinds, handle app spawning, and do other computation. I do not yet see Docker or Kubernetes as seamless integration. I think for a long while I will be manually configuring and balancing a small set of NodeJS-optimized servers. Cheers to simplicity.</div></div><hr><div id='post'><div id='posttitle'>Developing with NodeJS</div><div id='	postdate'>Mon May 25 2015 23:15:30 GMT-0700 (PDT)</div><br><div id='posttext'>I've had a great time working on the series of apps located at bwackwat.com. I plan to sharpen the sites and work on some nice NodeJS-based "app" infrastructure. In the future I will consider using Docker for scalability purposes. In addition, although MongoDB integrates nicely with both Javascript objects and my brain's organization, I am interested in entertaining the idea of using Redis, or an ACID compatible database.<br>As for NodeJS:  Javascript is awesome to use for front and back end work, the community of coders and support for libraries is good if not great, and I am enjoying it's ease of deployment. I hope it can scale. MongoDB is great for general document storage.<br>I am really looking forward to having more fun with WebSockets.</div></div><hr></div>